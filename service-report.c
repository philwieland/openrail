/*
    Copyright (C) 2013, 2014, 2017, 2018, 2020, 2022 Phil Wieland

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    phil@philwieland.com

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>
#include <time.h>
#include <mysql.h>
#include <unistd.h>

#include "misc.h"
#include "db.h"
#include "build.h"

static void report(const char * const tiploc, const word year, const word month);
static void report_day(const char * const tiploc, time_t when);
static void report_train_day(const word index, const time_t when, const char * const tiploc);
static char * percentage(const dword num, const dword den);

#define NAME "service-report"
#ifndef RELEASE_BUILD
#define BUILD "3c06p"
#else
#define BUILD RELEASE_BUILD
#endif

static word debug;
static word bus;
static word nlate, nlater, ncape, nbus, ntrain;
static word glate, glater, gcape, gbus, gtrain;

// Days runs fields
static const char * days_runs[8] = {"runs_su", "runs_mo", "runs_tu", "runs_we", "runs_th", "runs_fr", "runs_sa", "runs_su"};

// (Hours * 60 + Minutes) * 4
#define DAY_START  4*60*4

static const char * days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

#define MAX_CALLS 2048
   static struct call_details
   {
      dword cif_schedule_id;
      dword cancelled_by;
      word sort_time;
      byte next_day;
      byte valid;
      byte terminates;
      char cif_stp_indicator;
      char cif_train_uid[8];
      char arrival[6], public_arrival[6], departure[6], public_departure[6], pass[6];
      char platform[4];
      char tiploc_code[8];
   } 
   calls[MAX_CALLS];
   static word call_sequence[MAX_CALLS];
   static word call_count;

int main(int argc, char **argv)
{
   int c;
   char config_file_path[256];
   word month, year;
   word usage = false;

   strcpy(config_file_path, "/etc/openrail.conf");
   debug = false;

   while ((c = getopt (argc, argv, ":c:d")) != -1)
   {
      switch (c)
      {
      case 'c':
         strcpy(config_file_path, optarg);
         break;
      case 'd':
         debug = true;
         break;
      case ':':
         break;
      case '?':
      default:
         usage = true;
         break;
      }
   }

   if(argc - optind < 3)
   {
      usage = true;
   }

   char * config_fail;
   if((config_fail = load_config(config_file_path)))
   {
      printf("Failed to read config file \"%s\":  %s\n", config_file_path, config_fail);
      usage = true;
   }

   // Debug is set from command line, not config
   //debug = *conf[conf_debug];

   if(load_config(config_file_path))
   {
      printf("Failed to read config file \"%s\".\n", config_file_path);
      usage = true;
   }
   if(!usage)
   {
      if(strlen(argv[optind]) > 8) usage = true;
      month = atoi(argv[optind+1]);
      year  = atoi(argv[optind+2]);
      if(month < 1 || month > 12 || year < 2013 || year > 2099) usage = true;
   }

   if(usage)
   {
      printf("\tUsage: %s [-c /path/to/config/file.conf] [-d] <TIPLOC> <month> <year>\n\n", argv[0] );
      exit(1);
   }

   // Initialise logging
   _log_init("", debug?1:0);

   // Initialise database
   db_init(conf[conf_db_server], conf[conf_db_user], conf[conf_db_password], conf[conf_db_name], DB_MODE_NORMAL);

   report(argv[optind], year, month);

   exit(0);
}

static void report(const char * const tiploc, const word year, const word month)
{
   char l[512];
   time_t when;
   struct tm broken;
   sprintf(l, "Reporting on \"%s\".  Month is %02d/%d.", tiploc, month, year);
   _log(GENERAL, l);

   broken.tm_mday = 1;
   broken.tm_mon = month - 1;
   broken.tm_year = year - 1900;
      
   broken.tm_hour = 12;
   broken.tm_min = 0;
   broken.tm_sec = 0;
   broken.tm_isdst = -1;
   when = timegm(&broken);

   glate = glater = gcape = gbus = gtrain = 0;

   printf("<!-- Report for trains at %s during %02d/%d generated by %s build %s -->\n\n", tiploc, month, year, NAME, BUILD);
   
   while(broken.tm_mon == month - 1)
   {
      report_day(tiploc, when);

      when += 24*60*60;
      broken = *gmtime(&when);
   }

   if(gtrain)
   {
      printf("<tr><td>%s</td><td>%d</td><td>%d</td><td>(%s%%)</td>",
             "Month", gtrain, gtrain-gcape, percentage(gtrain-gcape, gtrain));
      printf("<td>%d</td><td>(%s%%)</td>",
             gtrain - glate, percentage(gtrain - glate, gtrain));
      printf("<td>%d</td><td>(%s%%)</td><td>%s</td></tr>\n",
             gtrain - glater, percentage(gtrain - glater, gtrain), "&nbsp;");
   }
   else
   {
      printf("<tr><td>%s</td><td>%d</td><td>%d</td><td>&nbsp;</td>",
             "Month", gtrain, gtrain-gcape);
      printf("<td>%d</td><td>&nbsp;</td>",
             gtrain - glate);
      printf("<td>%d</td><td>&nbsp;</td><td>%s</td></tr>\n",
             gtrain - glater, "&nbsp;");
   }
   printf("<!-- End of report -->\n\n"); 
  
}

static void report_day(const char * const tiploc, time_t when)
{
   MYSQL_RES * result0;
   MYSQL_ROW row0;
   char query[4096], zs[256];
   // When will be 12:00:00Z on the day in question (Or 11:00 or 13:00 if the clocks have changed)

   //                    0                          1                      2                             3         4
   strcpy(query, "SELECT cif_schedules.id, cif_schedules.CIF_train_uid, cif_schedules.CIF_stp_indicator, next_day, sort_time, record_identity, arrival, public_arrival, departure, public_departure, pass, platform, tiploc_code");
   strcat(query, " FROM cif_schedules INNER JOIN cif_schedule_locations");
   strcat(query, " ON cif_schedules.id = cif_schedule_locations.cif_schedule_id");
   sprintf(zs, " WHERE (cif_schedule_locations.tiploc_code = '%s')", tiploc);
   strcat(query, zs);
   
   strcat(query, " AND (cif_schedules.CIF_stp_indicator = 'N' OR cif_schedules.CIF_stp_indicator = 'P' OR cif_schedules.CIF_stp_indicator = 'O')");
   
   sprintf(zs, " AND deleted >= %ld AND created <= %ld", when + (12*60*60), when + (12*60*60));
   strcat(query, zs);
   
   // Select the day
   struct tm * broken = gmtime(&when);
   word day = broken->tm_wday;
   word mday = broken->tm_mday;
   word yest = (day + 6) % 7;
   word tom = (day + 1) % 7;
      
   sprintf(zs, " AND ((((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld) AND (NOT next_day)) AND (sort_time >= %d))",  days_runs[day],  when + 12*60*60, when - 12*60*60, DAY_START);
   strcat(query, zs);
   sprintf(zs, " OR   (((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld) AND (    next_day)) AND (sort_time >= %d))",  days_runs[yest], when - 12*60*60, when - 36*60*60, DAY_START);
   strcat(query, zs);
   sprintf(zs, " OR   (((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld) AND (NOT next_day)) AND (sort_time <  %d))",  days_runs[tom],  when + 36*60*60, when + 12*60*60, DAY_START); 
   strcat(query, zs);
   sprintf(zs, " OR   (((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld) AND (    next_day)) AND (sort_time <  %d)))", days_runs[day],  when + 12*60*60, when - 12*60*60, DAY_START);
   strcat(query, zs);
   
   sprintf(zs, " AND (public_departure != '' OR departure != '') AND (train_status = 'P' OR train_status = 'B' OR train_status = '1' OR train_status = '5')");
   strcat(query, zs);
      // And exclude ECS
      sprintf(zs, " AND (cif_train_category not like 'E%%')");
      strcat(query, zs);
   
   strcat(query, " ORDER BY LOCATE(cif_schedules.CIF_stp_indicator, 'NPO'), cif_schedule_id"); 
   
   word index, i;
   
   // 1. Collect a list of calls
   call_count = 0;
   //printf("<p>[%s]</p>", query);
   
   if(!db_query(query))
   {
      result0 = db_store_result();
      while((row0 = mysql_fetch_row(result0)))
      {
         if(call_count >= MAX_CALLS)
         {
            printf("Error: MAX_CALLS exceeded.\n");
            return;
         }

         // Insert in array
         calls[call_count].cif_schedule_id        = atol(row0[0]);
         calls[call_count].cancelled_by           = 0;
         calls[call_count].sort_time              = atoi(row0[4]);
         calls[call_count].next_day               = atoi(row0[3]);
         calls[call_count].valid                  = true;
         calls[call_count].terminates             = !(strcmp(row0[5], "LT"));;
         calls[call_count].cif_stp_indicator      = row0[2][0];
         strcpy(calls[call_count].cif_train_uid,    row0[1]);
         strcpy(calls[call_count].arrival,          row0[6]);
         strcpy(calls[call_count].public_arrival,   row0[7]);
         strcpy(calls[call_count].departure,        row0[8]);
         strcpy(calls[call_count].public_departure, row0[9]);
         strcpy(calls[call_count].pass,             row0[10]);
         strcpy(calls[call_count].platform,         row0[11]);
         strcpy(calls[call_count].tiploc_code,      row0[12]);
         call_count++;
      }
      mysql_free_result(result0);
   }
   
   // 2. Cancel any which are overriden
   for(index = 1; index < call_count; index++)
   {
      if(calls[index].valid && calls[index].cif_stp_indicator == 'O')
      {
         for(i = 0; i < index; i++)
         {
            if(!strcmp(calls[i].cif_train_uid, calls[index].cif_train_uid) && calls[i].cif_stp_indicator != 'O')
            {
               // Hit
               calls[i].valid = false;
            }
         }
      }
   }
   
   // 3. Next, remove those which are cancelled, and remove those overriden by overlays that don't call
   // NOTE:  Overlay may not call at this station!
   sprintf(zs, "3. Commencing C and O check.  day = %d", day);
   _log(DEBUG, zs);
   
   for(index = 0; index < call_count; index++)
   {
      if(calls[index].valid)
      {
         sprintf(zs, "Testing index %d train \"%s\", sort_time = %d, next_day = %d", index, calls[index].cif_train_uid, calls[index].sort_time, calls[index].next_day );
         _log(DEBUG, zs);
         //                    0   1                 2                               3
         strcpy(query, "SELECT id, CIF_stp_indicator, update_id ");
         strcat(query, " FROM cif_schedules");
         strcat(query, " WHERE (cif_stp_indicator = 'C' OR cif_stp_indicator = 'O')");
         sprintf(zs, " AND (CIF_train_uid = '%s')", calls[index].cif_train_uid);
         strcat(query, zs);
         sprintf(zs, " AND (deleted >= %ld) AND (created <= %ld)", when + (12*60*60), when + (12*60*60));
         strcat(query, zs);

         if(calls[index].next_day && calls[index].sort_time >= DAY_START)
         {
            sprintf(zs, " AND ((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld))",  days_runs[yest], when - 12*60*60, when - 36*60*60);
            strcat(query, zs);
         }
         else if(calls[index].next_day && calls[index].sort_time < DAY_START)
         {
            sprintf(zs, " AND ((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld))", days_runs[day],  when + 12*60*60, when - 12*60*60);
            strcat(query, zs);
         }
         else if(!calls[index].next_day && calls[index].sort_time >= DAY_START)
         {
            sprintf(zs, " AND ((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld))",  days_runs[day],  when + 12*60*60, when - 12*60*60);
            strcat(query, zs);
         }
         else if(!calls[index].next_day && calls[index].sort_time < DAY_START)
         {
            sprintf(zs, " AND ((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld))",  days_runs[tom],  when + 36*60*60, when + 12*60*60); 
            strcat(query, zs);
         }
         if(!db_query(query))
         {
            result0 = db_store_result();
            while((row0 = mysql_fetch_row(result0)))
            {
               _log(DEBUG, "Index C or O match:");
               if(row0[1][0] == 'C')
               {
                  if(atol(row0[2]))
                  {
                     // Cancelled
                     calls[index].valid = false;
                     //printf("<br>Step 3:  %d invalidated due to C", index);
                     _log(DEBUG, "Schedule %ld (%s) cancelled by schedule %s.", calls[index].cif_schedule_id, calls[index].cif_train_uid, row0[0]);
                  }
                  else
                  {
                     // VSTP cancellation to be shown as Cancelled rather than omitted.
                     calls[index].cancelled_by = atol(row0[0]);
                     _log(DEBUG, "Schedule %ld (%s) VSTP cancelled by schedule %s.", calls[index].cif_schedule_id, calls[index].cif_train_uid, row0[0]);
                  }
               }
               else 
               {
                  // Overlay
                  // We will come here with an overlay we already know about OR one which *doesn't come here*
                  // In either case we invalidate this schedule.  If the overlay comes here it will already be in the list, somewhere.
                  dword overlay_id = atol(row0[0]);
                  _log(DEBUG, "Overlay id = %ld, train id = %ld", overlay_id, calls[index].cif_schedule_id);
                  if(overlay_id != calls[index].cif_schedule_id || calls[index].cif_stp_indicator == 'N' || calls[index].cif_stp_indicator == 'P')
                  {
                     // Special case: If, due to defective data, there are two valid overlays, we need the first to be invalidated by the second, but not vice versa.
                     word special = false;
                     word i;
                     for(i = 0; i < call_count && !special; i++)
                     {
                        if(i != index && calls[i].cif_schedule_id == overlay_id && !calls[i].valid) special = true;
                     }
                  
                     if(special)
                     {
                        _log(DEBUG, "Step 3:  %d NOT invalidated due to O id = %s due to duplicate overlay.", index, row0[0]);
                     }
                     else
                     {
                        // Supercede
                        calls[index].valid = false;
                        _log(DEBUG, "Step 3:  %d invalidated due to O id = %s", index, row0[0]);
                     }
                  }
               }
            }
            mysql_free_result(result0);
         }
      }
   }

   // 5. Bubble Sort
   {
      word i,j;

      word run = true;

     // First, mung the sort_time so that early hours trains come after the others:
      for(j=0; j< call_count; j++)
      {
         // Early hours trains come after all the others.
         if(calls[j].sort_time < DAY_START) calls[j].sort_time += 10000;
         call_sequence[j] = j;
      }

      for(j = call_count; run && j > 1; j--)
      {
         run = false;
         for(i=1; i < j; i++)
         {
            if(calls[call_sequence[i]].sort_time < calls[call_sequence[i-1]].sort_time)
            {
               run = true;
               // Swap
               word tempo = call_sequence[i];
               call_sequence[i] = call_sequence[i-1];
               call_sequence[i-1] = tempo;
            }
         }
      }
   }
   
   nlate = nlater = ncape = ntrain = nbus = 0;
   for(index = 0; index < call_count; index++)
   {
      if(calls[call_sequence[index]].valid)
      {
         report_train_day(call_sequence[index], when, tiploc);
      }
   }

   // See if there are any notes
   char notes[4096];
   strcpy(notes, "&nbsp;");
   {
      FILE * fp = fopen("/home/wielanpj/report-notes.txt", "r");
      char line[256];
      word match = false;
      if(fp)
      {
         broken = gmtime(&when);
         while(fgets(line, 256, fp))
         {
            if(line[0] == '>')
            {
               // Date
               if(broken->tm_mday == atoi(line + 1) && broken->tm_mon + 1 == atoi(line + 4) && broken->tm_year % 100 == atoi(line + 7))
               {
                  match = true;
                  notes[0] = '\0';
               }
               else
               {
                  match = false;
               }
            }
            else if(match && line[0] != '\n') strcat(notes, line);
         }
         fclose(fp);
      }
      if(notes[strlen(notes) - 1] == '\n') notes[strlen(notes) - 1] = '\0';
   }

   if(ntrain)
   {
      printf("<tr><td>%s %02d</td><td>%d</td><td>%d</td><td%s>(%s%%)</td>",
             days[day % 7], mday, ntrain, ntrain - ncape, (ncape)?"":" bgcolor=\"#00ff00\"", percentage(ntrain - ncape, ntrain));
      printf("<td>%d</td><td%s>(%s%%)</td>",
             ntrain - ncape - nlate, (ncape + nlate)?"":" bgcolor=\"#00ff00\"", percentage(ntrain - ncape - nlate, ntrain));
      printf("<td>%d</td><td%s>(%s%%)</td><td align=\"left\">%s</td></tr>\n",
             ntrain - ncape - nlater, (ncape + nlater)?"":" bgcolor=\"#00ff00\"", percentage(ntrain - ncape - nlater, ntrain), notes);
   }
   else
   {
      printf("<tr><td>%s %02d</td><td>%d</td><td>%d</td><td>&nbsp;</td>",
             days[day % 7], mday, ntrain, ntrain-ncape);
      printf("<td>%d</td><td>&nbsp;</td>",
             0);
      printf("<td>%d</td><td>&nbsp;</td><td align=\"left\">%s</td></tr>\n",
             0, notes);
   }

   gtrain += ntrain;
   gcape += ncape;
   glate += nlate;
   glater += nlater;
   gbus += nbus;
}

static void report_train_day(const word index, const time_t when, const char * const tiploc)
{
   enum statuses {NoReport, Activated, Moving, Cancelled, Arrived, Departed};
   MYSQL_RES * result0, * result1;
   MYSQL_ROW row0, row1;

   char query[1024];
   word status;
   char actual[16];
   word deviation, deduced, late;
   struct tm * broken;

   deviation = late = status = bus = deduced = 0;
   dword cif_schedule_id = calls[index].cif_schedule_id;
   
   _log(DEBUG, "report_train_day(%ld, %ld, \"%s\")", cif_schedule_id, when, tiploc);
   
   //                     0             1                    2                  3              4              5                  6           
   sprintf(query, "SELECT train_status, schedule_start_date, schedule_end_date, signalling_id, CIF_train_uid, CIF_stp_indicator, update_id FROM cif_schedules WHERE id = %u", cif_schedule_id);

   if(!db_query(query))
   {
      result0 = db_store_result();

      if((row0 = mysql_fetch_row(result0)))
      {
         bus = (row0[0][0] == 'B' || row0[0][0] == '5');

         if(!bus) ntrain++;
         status = NoReport;
         // TRUST
         if(!bus)
         {
            char query[512], trust_id[16];
            MYSQL_RES * result2;
            MYSQL_ROW row2;
            broken = gmtime(&when);
            byte dom = broken->tm_mday;

            // Only accept activations where dom matches, and are +- 15 days (To eliminate last month's activation.)  YUK
            sprintf(query, "SELECT created, trust_id, deduced FROM trust_activation WHERE cif_schedule_id = %u AND substring(trust_id FROM 9) = '%02d' AND created > %ld AND created < %ld order by created DESC", cif_schedule_id, dom, when - 15*24*60*60, when + 15*24*60*60);
            if(!db_query(query))
            {
               result1 = db_store_result();
               if((row1 = mysql_fetch_row(result1)))
               {
                  status = Activated;
                  strcpy(trust_id, row1[1]);
               }
               mysql_free_result(result1);
            }

            if(status)
            {
               sprintf(query, "SELECT flags, loc_stanox, actual_timestamp, timetable_variation from trust_movement where trust_id='%s' AND created > %ld AND created < %ld order by actual_timestamp, planned_timestamp, created", trust_id, when - 15*24*60*60, when + 15*24*60*60);
               if(!db_query(query))
               {
                  result1 = db_store_result();
                  while((row1 = mysql_fetch_row(result1)))
                  {
                     word flags = atoi(row1[0]);
                     if(status < 4)
                     {
                        status = Moving;
                        strcpy(actual, row1[2]);
                        deviation = atoi(row1[3]);
                        late = ((flags & 0x0018) == 0x0010);
                     }
                     if(status < Departed)
                     {
                        sprintf(query, "SELECT tiploc FROM corpus WHERE stanox = %s", row1[1]);
                        if(!db_query(query))
                        {
                           result2 = db_store_result();
                           if((row2 = mysql_fetch_row(result2)))
                           {
                              if(!strcasecmp(tiploc, row2[0]))
                              {
                                 // Bug: For a train which calls twice, we will only analyse the first visit.
                                 if((flags & 0x0003) == 0x0001)
                                 {
                                    // Got a departure report at our station
                                    status = Departed;
                                    strcpy(actual, row1[2]);
                                    deviation = atoi(row1[3]);
                                    late = ((flags & 0x0018) == 0x0010);
                                 }
                                 else if(status < Arrived)
                                 {
                                    // Got an arrival at our station AND haven't seen a departure yet
                                    status = Arrived;
                                 }
                              }
                           }
                           mysql_free_result(result2);
                        }
                     }
                  }
                  mysql_free_result(result1);
               }
            }
            
            if(status < Arrived)
            {
               // Check for cancellations.  We only do this if the train hasn't called.
               word save_status = status;
               if(!calls[index].cancelled_by)
               {
                  sprintf(query, "SELECT created, reason, type, reinstate from trust_cancellation where trust_id='%s' AND created > %ld AND created < %ld order by created ", trust_id, when - 15*24*60*60, when + 15*24*60*60);                  
                  if(!db_query(query))
                  {                   
                     result2 = db_store_result();
                     while((row2 = mysql_fetch_row(result2)))
                     {
                        if(atoi(row2[3]))
                        {
                           status = save_status;
                        }
                        else
                        {
                           status = Cancelled;
                        }
                     }
                     mysql_free_result(result2);
                  }
               }
               else
               {
                  status = Cancelled; 
               }
            }
         }
      }
      mysql_free_result(result0);
   }

   // Build analysis
   switch(status)
   {
   case NoReport: 
      if(bus) 
      {
         nbus++;
      }
      break;

   case Activated: // Activated
      break;

   case Moving: // Moved
      if(deviation > 2) nlate++;
      if(deviation > 5) nlater++;
      break;

   case Cancelled: // Cape
      ncape++;
      break;

   case Arrived: // Arrived
   case Departed: // Departed
      if(deviation > 2) nlate++;
      if(deviation > 5) nlater++;
      break;

   }

   return;
}

static char * percentage(const dword num, const dword den)
{
   static char result[16];

   if(den)
   {
      dword permille = 1000 * num / den;
      sprintf(result, "%u.%u", permille/10, permille%10);
   }
   else
   {
      strcpy(result, "-");
   }

   return result;
}
